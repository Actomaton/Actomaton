{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actomaton を使ったアプリのビジネスロジックを作成するために最低限、必要な情報は："}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Action (入力) の型定義"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"State (状態) の型定義"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reducer (状態遷移関数) の実装"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"の3つです。この例では、これらの定義の仕方について見ていきます。"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"（他にも、副作用に関連する "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":", "},{"type":"codeVoice","code":"Environment"},{"type":"text","text":", "},{"type":"codeVoice","code":"Route"},{"type":"text","text":" がありますが、この記事では使用しません）"}]},{"anchor":"カウンターのビジネスロジック","level":3,"type":"heading","text":"カウンターのビジネスロジック"},{"type":"paragraph","inlineContent":[{"type":"text","text":"今回は、"},{"type":"codeVoice","code":"increment"},{"type":"text","text":" と "},{"type":"codeVoice","code":"decrement"},{"type":"text","text":" を行うシンプルなカウンターを題材に、上記3点を次のように定義します。"}]},{"type":"codeListing","syntax":"swift","code":["import ActomatonUI","","\/\/ 入力アクション (Sendable が必要)","enum Action: Sendable {","    case increment","    case decrement","}","","\/\/ 状態 (Sendable が必要)","\/\/ NOTE: Equatable にしておくと差分更新とテスト比較がしやすいので、基本的に付けること。","struct State: Equatable, Sendable {","    var count: Int = 0","}","","\/\/ 外部環境からの副作用の依存注入は今回必要ないので、Void 。","\/\/ NOTE: Never ではないので注意。通常は struct で定義する。","typealias Environment = Void","","\/\/ 他画面へのルーティング処理は今回必要ないので、Never 。","\/\/ NOTE: Void ではないので注意。通常は enum で定義する。","typealias Route = Never","","\/\/ 状態遷移関数：アクションが送られる度に呼ばれる","let reducer: Reducer<Action, State, Environment>","reducer = Reducer { action, state, environment in","    switch action { \/\/ 受信したアクションをパターンマッチで分岐処理","    case .increment:","        state.count += 1    \/\/ 状態を更新","        return Effect.empty \/\/ 副作用を出力（ここでは空）","    case .decrement:","        state.count -= 1","        return Effect.empty","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"カウンターのビジネスロジックは以上で完成です。"}]},{"anchor":"カウンターの-UI-view-binding","level":3,"type":"heading","text":"カウンターの UI view binding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"上記のビジネスロジックを UI に反映する方法として、"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI View"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit View"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"それぞれについて見ていきます。"}]},{"anchor":"1.-SwiftUI-View-の場合","level":4,"type":"heading","text":"1. SwiftUI View の場合"},{"type":"paragraph","inlineContent":[{"type":"text","text":"まずはじめに、 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store"},{"type":"text","text":" を View 内部で宣言します。"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftUI","import ActomatonUI","","@MainActor","struct CounterView: View {","    \/\/ Store を作成","    private let store: Store<Action, State, Environment, Route> = .init(","        state: State(),","        reducer: reducer","    )","","    var body: some View {","        \/\/ 注意： store.state にアクセスしても、View は更新されません ","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ここで "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Store"},{"type":"text","text":" はまだ SwiftUI View と連携していない"}]},{"type":"text","text":" 点に注意してください。"},{"type":"text","text":" "},{"type":"text","text":"つまり、 "},{"type":"codeVoice","code":"store.state"},{"type":"text","text":" を直接呼んでも "},{"type":"codeVoice","code":"CounterView"},{"type":"text","text":" は再レンダリングの対象になりません。"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI と連携するには、 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/WithViewStore"},{"type":"text","text":" (SwiftUI View) を使って、 "},{"type":"strong","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store"},{"type":"text","text":" から "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore"},{"type":"text","text":" を作る"}]},{"type":"text","text":" 必要があります。"},{"type":"text","text":" "},{"type":"text","text":"これにより、"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/WithViewStore"},{"type":"text","text":" 内部で監視可能な "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore"},{"type":"text","text":" を保持し、その内部 View を再レンダリングすることができます。"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftUI","import ActomatonUI","","@MainActor","struct CounterView: View {","    \/\/ Store を作成","    private let store: Store<Action, State, Environment> = .init(","        state: State(),","        reducer: reducer","    )","","    var body: some View {","        \/\/ `WithViewStore` を使って Store から ViewStore に変換。","        \/\/ これにより、`WithViewStore` (View) が `self.store` の状態更新に対応して内部の再レンダリングが可能。","        WithViewStore(self.store) { viewStore in ","            HStack {","                \/\/ ボタン： decrement を送信","                Button(action: { store.send(.decrement) }) {","                    Image(systemName: \"minus.circle\")","                }","","                \/\/ 現在のカウントを画面に表示","                Text(\"Count: \\(viewStore.state.count)\")","","                \/\/ ボタン： increment を送信","                Button(action: { store.send(.increment) }) {","                    Image(systemName: \"plus.circle\")","                }","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Store"},{"type":"text","text":" の状態を参照するには "},{"type":"codeVoice","code":"viewStore.state"},{"type":"text","text":"、次のアクションを送る場合は "},{"type":"codeVoice","code":"store.send()"},{"type":"text","text":" を呼び出します。"}]},{"type":"aside","style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" の状態を参照するには "},{"type":"codeVoice","code":"viewStore.state"},{"type":"text","text":" 以外に "},{"type":"codeVoice","code":"store.state"},{"type":"text","text":" も可能ですが、"},{"type":"text","text":" "},{"type":"text","text":"状態へのアクセスは基本的に "},{"type":"codeVoice","code":"viewStore"},{"type":"text","text":" の方を使うようにしましょう。"},{"type":"text","text":" "},{"type":"text","text":"その理由は、 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore\/binding(get:onChange:)"},{"type":"text","text":" などの「状態 "},{"type":"codeVoice","code":"Binding"},{"type":"text","text":"」が、このクラスでのみ呼び出し可能なためです。"},{"type":"text","text":" "},{"type":"text","text":"状態以外のアクセス（e.g. アクションを送る、依存コンテナ "},{"type":"codeVoice","code":"Environment"},{"type":"text","text":" にアクセスする）については、"},{"type":"text","text":" "},{"type":"codeVoice","code":"store.send()"},{"type":"text","text":"、"},{"type":"codeVoice","code":"store.environment"},{"type":"text","text":" を使います。"}]}]},{"anchor":"2.-UIKit-View-の場合","level":4,"type":"heading","text":"2. UIKit View の場合"},{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit 実装では、 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store"},{"type":"text","text":" の状態更新を受け取る "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" ("},{"type":"codeVoice","code":"store.$state"},{"type":"text","text":") を使って簡単に UI binding を適用することができます。"}]},{"type":"codeListing","syntax":"swift","code":["import UIKit","import ActomatonUI","import Combine","","final class ViewController: UIViewController {","    \/\/ Store を作成","    private let store: Store<Action, State, Environment, Route> = .init(","        state: State(),","        reducer: reducer","    ) ","","    private var cancellables: Set<AnyCancellable> = []","","    override func viewDidLoad() {","        super.viewDidLoad()","","        let counterLabel = UILabel()","        let incrementButton = UIButton()","        let decrementButton = UIButton()","","        ...","","        \/\/ 以下は、Store との UIKit view binding","","        store.$state","            .map { \"Count: \\($0.count)\" }","            .removeDuplicates() \/\/ NOTE: 前回分と比較して同じなら無視する","            .assign(to: \\.text, on: counterLabel)","            .store(in: &cancellables)","","        incrementButton.tapPublisher","            .sink { [store] in","                store.send(.increment) \/\/ アクションを送る","            }","            .store(in: &cancellables)","","        decrementButton.tapPublisher","            .sink { [store] in","                store.send(.decrement) \/\/ アクションを送る","            }","            .store(in: &cancellables)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ここで Combine Publisher の "},{"type":"codeVoice","code":"removeDuplicates()"},{"type":"text","text":" を使って、必要な変更のみを UI binding すると良いでしょう。"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"さあ、これで完成です！"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" を従来の MVVM ViewModel に見立てると、ほとんど書き方が似ていることが分かります。"}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"Actomaton が従来の MVVM と異なる点として次のようなものがあります："}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MVVM のメソッド”直接”呼び出しに対して、Actomaton では enum を使ってメソッド群を定義し、"},{"type":"codeVoice","code":"store.send(action)"},{"type":"text","text":" でメッセージとして送信している（“間接”呼び出し）"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MVVM では個々の状態の "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" を集めて（複雑な）"},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" 全体の状態が作られるのに対して、Actomaton では全体の状態がシンプルな "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" で出来ている"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"複数画面の状態を合成する際に、シンプルな構成の方が有利。例えば、"},{"type":"codeVoice","code":"store.$state"},{"type":"text","text":" で状態全体を1本の "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" で一括で受け取れる (MVVM では事前に "},{"type":"codeVoice","code":"combineLatest"},{"type":"text","text":" 等をたくさん書く必要がある)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"状態がシンプルな "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" でもあるので、複数の状態をまとめて次の "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" (非同期計算)に渡すことが出来る"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"その一方で、UI binding 毎に "},{"type":"codeVoice","code":".map"},{"type":"text","text":" と "},{"type":"codeVoice","code":".removeDuplicates()"},{"type":"text","text":" を追加で書く手間がかかる"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actomaton のような「状態を一括で受け取れる」設計は、UI binding と差分更新が自動的に適用される SwiftUI で特に真価を発揮します。"},{"type":"text","text":" "},{"type":"text","text":"そのビジネスロジックの基本設計図をそのまま UIKit にも適用できるのが、この "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" を使った例です。"}]}]},{"anchor":"サンプルコード","level":2,"type":"heading","text":"サンプルコード"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm"}]}]}]},{"anchor":"Next-Step","level":2,"type":"heading","text":"Next Step"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/02-LoginLogout"}]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/actomatonui\/01-counter"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/01-Counter","interfaceLanguage":"swift"},"abstract":[{"type":"codeVoice","code":"increment"},{"type":"text","text":" と "},{"type":"codeVoice","code":"decrement"},{"type":"text","text":" を行うカウンターの例"}],"kind":"article","metadata":{"roleHeading":"Article","title":"1. シンプルなカウンター","role":"article","modules":[{"name":"ActomatonUI"}]},"hierarchy":{"paths":[["doc:\/\/ActomatonUI\/documentation\/ActomatonUI"]]},"references":{"https://github.com/Actomaton/Actomaton-Gallery/tree/main/Examples/Actomaton-Basic.swiftpm":{"title":"Actomaton-Basic","titleInlineContent":[{"type":"text","text":"Actomaton-Basic"}],"type":"link","identifier":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm","url":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm"},"doc://ActomatonUI/documentation/ActomatonUI/Store":{"role":"symbol","title":"Store","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[{"type":"codeVoice","code":"MainActomaton"},{"type":"text","text":"-erased wrapper which can "},{"type":"codeVoice","code":"map(state:)-1wcms"},{"type":"text","text":" into sub-store."}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/actomatonui\/store"},"doc://ActomatonUI/documentation/ActomatonUI/02-LoginLogout":{"role":"article","title":"2. 認証フローの状態管理・副作用管理","abstract":[{"type":"text","text":"認証フローで行われる複雑な状態管理とその副作用管理を扱う例"}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/02-LoginLogout","kind":"article","type":"topic","url":"\/documentation\/actomatonui\/02-loginlogout"},"doc://ActomatonUI/documentation/ActomatonUI":{"role":"collection","title":"ActomatonUI","abstract":[{"type":"text","text":"Swift Concurrency (async\/await、Structured Concurrency、Actor) を使った、状態と副作用の管理のためのフレームワーク。"}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI","kind":"symbol","type":"topic","url":"\/documentation\/actomatonui"},"doc://ActomatonUI/documentation/ActomatonUI/ViewStore":{"role":"symbol","title":"ViewStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ViewStore"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store"},{"type":"text","text":"’s "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" proxy type that can create direct (state-to-state) & indirect (state-to-action) "},{"type":"codeVoice","code":"Binding"},{"type":"text","text":"s."}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ViewStore"}],"url":"\/documentation\/actomatonui\/viewstore"},"doc://ActomatonUI/documentation/ActomatonUI/ViewStore/binding(get:onChange:)":{"conformance":{"constraints":[{"type":"codeVoice","code":"Action"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"State"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"binding(get:onChange:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"binding"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"SubState"},{"kind":"text","text":">("},{"kind":"externalParam","text":"get"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"State","preciseIdentifier":"s:11ActomatonUI9ViewStoreC5Stateq_mfp"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"SubState","preciseIdentifier":"s:11ActomatonUI9ViewStoreC7binding3get8onChange05SwiftB07BindingVyqd__Gqd__q_c_xSgqd__ctlF8SubStateL_qd__mfp"},{"kind":"text","text":", "},{"kind":"externalParam","text":"onChange"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"SubState","preciseIdentifier":"s:11ActomatonUI9ViewStoreC7binding3get8onChange05SwiftB07BindingVyqd__Gqd__q_c_xSgqd__ctlF8SubStateL_qd__mfp"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Action","preciseIdentifier":"s:11ActomatonUI9ViewStoreC6Actionxmfp"},{"kind":"text","text":"?) -> "},{"kind":"typeIdentifier","text":"Binding","preciseIdentifier":"s:7SwiftUI7BindingV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"SubState","preciseIdentifier":"s:11ActomatonUI9ViewStoreC7binding3get8onChange05SwiftB07BindingVyqd__Gqd__q_c_xSgqd__ctlF8SubStateL_qd__mfp"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Indirect state-to-action conversion binding to create "},{"type":"codeVoice","code":"Binding<SubState>"},{"type":"text","text":"."}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore\/binding(get:onChange:)","kind":"symbol","type":"topic","url":"\/documentation\/actomatonui\/viewstore\/binding(get:onchange:)"},"doc://ActomatonUI/documentation/ActomatonUI/WithViewStore":{"role":"symbol","title":"WithViewStore","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"WithViewStore"}],"abstract":[{"type":"text","text":"Observable "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/ViewStore"},{"type":"text","text":" holder view that is created from unobservable "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/Store"},{"type":"text","text":"."}],"identifier":"doc:\/\/ActomatonUI\/documentation\/ActomatonUI\/WithViewStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WithViewStore"}],"url":"\/documentation\/actomatonui\/withviewstore"}}}