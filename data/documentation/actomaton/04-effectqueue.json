{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueue"},{"type":"text","text":" provides an easy-to-use effect queueing management system in Actomaton which allows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Suspending newly arrived effects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Discard old \/ new effects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Delays next executing effect"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["enum Action: Sendable {","    case fetch(id: String)","    case _didFetch(Data)","}","","struct State: Sendable {} \/\/ no state","","struct Environment: Sendable {","    let fetch: @Sendable (_ id: String) async throws -> Data","}","","struct DelayedEffectQueue: EffectQueueProtocol {","    \/\/ First 3 effects will run concurrently, and other sent effects will be suspended.","    var effectQueuePolicy: EffectQueuePolicy {","        .runOldest(maxCount: 3, .suspendNew)","    }","","    \/\/ Adds delay between effect start. (This is useful for throttling \/ deboucing)","    var effectQueueDelay: EffectQueueDelay {","        .random(0.1 ... 0.3)","    }","}","","let reducer = Reducer<Action, State, Environment> { action, state, environment in","    switch action {","    case let .fetch(id):","        return Effect(queue: DelayedEffectQueue()) {","            let data = try await environment.fetch(id)","            return ._didFetch(data)","        }","    case let ._didFetch(data):","        \/\/ Do something with `data`.","        return .empty","    }","}","","let actomaton = Actomaton<Action, State>(","    state: State(),","    reducer: reducer,","        environment: Environment(fetch: { \/* ... *\/ })",")","","await actomaton.send(.fetch(id: \"item1\"))","await actomaton.send(.fetch(id: \"item2\")) \/\/ min delay of 0.1","await actomaton.send(.fetch(id: \"item3\")) \/\/ min delay of 0.1 (after item2 actually starts)","await actomaton.send(.fetch(id: \"item4\")) \/\/ starts when item1 or 2 or 3 finishes"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Above code uses a custom "},{"type":"codeVoice","code":"DelayedEffectQueue"},{"type":"text","text":" that conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueProtocol"},{"type":"text","text":" with suspendable "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueuePolicy"},{"type":"text","text":" and delays between each effect by "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueDelay"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Actomaton\/Actomaton\/blob\/main\/Sources\/Actomaton\/EffectQueuePolicy.swift"},{"type":"text","text":" for how each policy takes different queueing strategy for effects."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ `EffectQueueProtocol`'s buffering policy.","public enum EffectQueuePolicy: Hashable, Sendable","{","    \/\/\/ Runs `maxCount` newest effects, cancelling old running effects.","    case runNewest(maxCount: Int)","","    \/\/\/ Runs `maxCount` old effects with either suspending or discarding new effects.","    case runOldest(maxCount: Int, OverflowPolicy)","","    public enum OverflowPolicy: Sendable","    {","        \/\/\/ Suspends new effects when `.runOldest` `maxCount` of old effects is reached until one of them is completed.","        case suspendNew","","        \/\/\/ Discards new effects when `.runOldest` `maxCount` of old effects is reached until one of them is completed.","        case discardNew","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For convenient "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueProtocol"},{"type":"text","text":" protocol conformance, there are built-in sub-protocols:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ A helper protocol where `effectQueuePolicy` is set to `.runNewest(maxCount: 1)`.","public protocol Newest1EffectQueueProtocol: EffectQueueProtocol {}","","\/\/\/ A helper protocol where `effectQueuePolicy` is set to `.runOldest(maxCount: 1, .discardNew)`.","public protocol Oldest1DiscardNewEffectQueueProtocol: EffectQueueProtocol {}","","\/\/\/ A helper protocol where `effectQueuePolicy` is set to `.runOldest(maxCount: 1, .suspendNew)`.","public protocol Oldest1SuspendNewEffectQueueProtocol: EffectQueueProtocol {}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"so that we can write in one-liner: "},{"type":"codeVoice","code":"struct MyEffectQueue: Newest1EffectQueueProtocol {}"}]},{"anchor":"Next-Step","level":2,"type":"heading","text":"Next Step"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/05-ReducerComposition"}]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/actomaton\/04-effectqueue"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Actomaton\/documentation\/Actomaton\/04-EffectQueue","interfaceLanguage":"swift"},"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueue"},{"type":"text","text":" example."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Example 4: EffectQueue","role":"article","modules":[{"name":"Actomaton"}]},"hierarchy":{"paths":[["doc:\/\/Actomaton\/documentation\/Actomaton"]]},"references":{"doc://Actomaton/documentation/Actomaton/EffectQueueDelay":{"role":"symbol","title":"EffectQueueDelay","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"EffectQueueDelay"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueProtocol"},{"type":"text","text":"’s  delaying strategy."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueDelay","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EffectQueueDelay"}],"url":"\/documentation\/actomaton\/effectqueuedelay"},"doc://Actomaton/documentation/Actomaton":{"role":"collection","title":"Actomaton","abstract":[{"type":"text","text":"Swift "},{"type":"codeVoice","code":"async"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"await"},{"type":"text","text":" & "},{"type":"codeVoice","code":"Actor"},{"type":"text","text":"-powered effectful state-management framework."},{"type":"text","text":" "},{"type":"text","text":"Linux ready."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton","kind":"symbol","type":"topic","url":"\/documentation\/actomaton"},"doc://Actomaton/documentation/Actomaton/EffectQueuePolicy":{"role":"symbol","title":"EffectQueuePolicy","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"EffectQueuePolicy"}],"abstract":[{"type":"codeVoice","code":"EffectQueueProtocol"},{"type":"text","text":"’s buffering policy."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueuePolicy","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EffectQueuePolicy"}],"url":"\/documentation\/actomaton\/effectqueuepolicy"},"doc://Actomaton/documentation/Actomaton/EffectQueueProtocol":{"role":"symbol","title":"EffectQueueProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"EffectQueueProtocol"}],"abstract":[{"type":"text","text":"A protocol that every effect queue should conform to, for automatic cancellation of existing tasks or suspending of new effects."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueueProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EffectQueueProtocol"}],"url":"\/documentation\/actomaton\/effectqueueprotocol"},"doc://Actomaton/documentation/Actomaton/05-ReducerComposition":{"role":"article","title":"Example 5: Making a large app (Reducer Composition)","abstract":[{"type":"text","text":"Reducer composition example."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/05-ReducerComposition","kind":"article","type":"topic","url":"\/documentation\/actomaton\/05-reducercomposition"},"doc://Actomaton/documentation/Actomaton/EffectQueue":{"role":"symbol","title":"EffectQueue","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"EffectQueue"}],"abstract":[{"type":"text","text":"Effect queue for automatic cancellation of existing tasks or suspending of new effects."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/EffectQueue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EffectQueue"}],"url":"\/documentation\/actomaton\/effectqueue"},"https://github.com/Actomaton/Actomaton/blob/main/Sources/Actomaton/EffectQueuePolicy.swift":{"title":"EffectQueuePolicy","titleInlineContent":[{"type":"text","text":"EffectQueuePolicy"}],"type":"link","identifier":"https:\/\/github.com\/Actomaton\/Actomaton\/blob\/main\/Sources\/Actomaton\/EffectQueuePolicy.swift","url":"https:\/\/github.com\/Actomaton\/Actomaton\/blob\/main\/Sources\/Actomaton\/EffectQueuePolicy.swift"}}}