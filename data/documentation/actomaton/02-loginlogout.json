{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example illustrates Auth state management where "},{"type":"codeVoice","code":"login"},{"type":"text","text":", "},{"type":"codeVoice","code":"logout"},{"type":"text","text":", and "},{"type":"codeVoice","code":"forceLogout"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"will trigger side-effects (such as API requests) then sends "},{"type":"codeVoice","code":"loginOK"},{"type":"text","text":" or "},{"type":"codeVoice","code":"logoutOK"},{"type":"text","text":" on completion."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"login-logout.png"}]},{"type":"codeListing","syntax":"swift","code":["enum Action: Sendable {","    case login, loginOK, logout, logoutOK","    case forceLogout","}","","enum State: Sendable {","    case loggedOut, loggingIn, loggedIn, loggingOut","}","","\/\/ NOTE:","\/\/ By attaching this EffectQueue to multiple `Effect`s,","\/\/ they will incorporate with each other under the same `EffectQueuePolicy`,","\/\/ in this case: `Newest1EffectQueueProtocol`.","\/\/ ","\/\/ This policy will only allow at most newest 1 effect to survive,","\/\/ and rest of the queued running effects will be automatically cancelled.","struct LoginFlowEffectQueue: Newest1EffectQueueProtocol {}","","struct Environment: Sendable {","    let loginEffect: @Sendable (userId: String) -> Effect<Action>","    let logoutEffect: Effect<Action>","}","","let environment = Environment(","    loginEffect: { userId in","        Effect(queue: LoginFlowEffectQueue()) {","            let loginRequest = ...","            let data = try? await URLSession.shared.data(for: loginRequest)","            if Task.isCancelled { return nil }","            ...","            return Action.loginOK \/\/ next action","        }","    },","    logoutEffect: {","        Effect(queue: LoginFlowEffectQueue()) {","            let logoutRequest = ...","            let data = try? await URLSession.shared.data(for: logoutRequest)","            if Task.isCancelled { return nil }","            ...","            return Action.logoutOK \/\/ next action","        }","    }",")","","let reducer = Reducer { action, state, environment in","    switch (action, state) {","    case (.login, .loggedOut):","        state = .loggingIn","        return environment.login(state.userId)","","    case (.loginOK, .loggingIn):","        state = .loggedIn","        return .empty","","    case (.logout, .loggedIn),","        (.forceLogout, .loggingIn),","        (.forceLogout, .loggedIn):","        state = .loggingOut","        return environment.logout()","","    case (.logoutOK, .loggingOut):","        state = .loggedOut","        return .empty","","    default:","        return Effect.fireAndForget {","            print(\"State transition failed...\")","        }","    }","}","","let actomaton = Actomaton<Action, State>(","    state: .loggedOut,","    reducer: reducer,","    environment: environment",")","","@main","enum Main {","    static func test_login_logout() async {","        var t: Task<(), Error>?","","        assertEqual(await actomaton.state, .loggedOut)","","        t = await actomaton.send(.login)","        assertEqual(await actomaton.state, .loggingIn)","","        await t?.value \/\/ wait for previous effect","        assertEqual(await actomaton.state, .loggedIn)","","        t = await actomaton.send(.logout)","        assertEqual(await actomaton.state, .loggingOut)","","        await t?.value \/\/ wait for previous effect","        assertEqual(await actomaton.state, .loggedOut)","","        XCTAssertFalse(isLoginCancelled)","    }","","    static func test_login_forceLogout() async throws {","        var t: Task<(), Error>?","","        assertEqual(await actomaton.state, .loggedOut)","","        await actomaton.send(.login)","        assertEqual(await actomaton.state, .loggingIn)","","        \/\/ Wait for a while and interrupt by `forceLogout`.","        \/\/ Login's effect will be automatically cancelled because of same `EffectQueue`.","        try await Task.sleep(\/* 1 ms *\/)","        t = await actomaton.send(.forceLogout)","","        assertEqual(await actomaton.state, .loggingOut)","","        await t?.value \/\/ wait for previous effect","        assertEqual(await actomaton.state, .loggedOut)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here we see the notions of "},{"type":"codeVoice","code":"EffectQueue"},{"type":"text","text":", "},{"type":"codeVoice","code":"Environment"},{"type":"text","text":", and "},{"type":"codeVoice","code":"let task: Task<(), Error> = actomaton.send(...)"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"EffectQueue"},{"type":"text","text":" is for automatic cancellation or suspension of effects."},{"type":"text","text":" "},{"type":"text","text":"In this example, "},{"type":"codeVoice","code":"Newest1EffectQueueProtocol"},{"type":"text","text":" is used so that only the newest 1 effect ("},{"type":"codeVoice","code":"forceLogout"},{"type":"text","text":") will survive,"},{"type":"text","text":" "},{"type":"text","text":"and rest of old queued effects (e.g. previous "},{"type":"codeVoice","code":"login"},{"type":"text","text":") will be automatically cancelled."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Environment"},{"type":"text","text":" is useful for injecting effects to be called inside "},{"type":"codeVoice","code":"Reducer"},{"type":"text","text":" so that they become replaceable."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Environment"},{"type":"text","text":" is known as Dependency Injection Container"}]},{"type":"text","text":" (using Reader monad)."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"(Optional) "},{"type":"codeVoice","code":"Task<(), Error>"},{"type":"text","text":" returned from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/Actomaton\/send(_:priority:tracksFeedbacks:)"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"is another fancy way of dealing with “all the effects triggered by "},{"type":"codeVoice","code":"action"},{"type":"text","text":"”."},{"type":"text","text":" "},{"type":"text","text":"We can call "},{"type":"codeVoice","code":"await task.value"},{"type":"text","text":" to wait for all of them to be completed,"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"task.cancel()"},{"type":"text","text":" to cancel all. Note that "},{"type":"codeVoice","code":"Actomaton"},{"type":"text","text":" already manages such "},{"type":"codeVoice","code":"task"},{"type":"text","text":"s for us internally,"},{"type":"text","text":" "},{"type":"text","text":"so we normally don’t need to handle them by ourselves (use this as a last resort!)."}]}]}]},{"anchor":"Next-Step","level":2,"type":"heading","text":"Next Step"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/03-Timer"}]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/actomaton\/02-loginlogout"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Actomaton\/documentation\/Actomaton\/02-LoginLogout","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Auth screen (login, logout, and force-logout) example."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Example 2: Auth state","role":"article","modules":[{"name":"Actomaton"}]},"hierarchy":{"paths":[["doc:\/\/Actomaton\/documentation\/Actomaton"]]},"references":{"doc://Actomaton/documentation/Actomaton":{"role":"collection","title":"Actomaton","abstract":[{"type":"text","text":"Swift "},{"type":"codeVoice","code":"async"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"await"},{"type":"text","text":" & "},{"type":"codeVoice","code":"Actor"},{"type":"text","text":"-powered effectful state-management framework."},{"type":"text","text":" "},{"type":"text","text":"Linux ready."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton","kind":"symbol","type":"topic","url":"\/documentation\/actomaton"},"login-logout.png":{"alt":"login-diagram","type":"image","identifier":"login-logout.png","variants":[{"url":"\/images\/login-logout.png","traits":["1x","light"]}]},"doc://Actomaton/documentation/Actomaton/Actomaton/send(_:priority:tracksFeedbacks:)":{"role":"symbol","title":"send(_:priority:tracksFeedbacks:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"send"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Action","preciseIdentifier":"s:9ActomatonAAC6Actionxmfp"},{"kind":"text","text":", "},{"kind":"externalParam","text":"priority"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"TaskPriority","preciseIdentifier":"s:ScP"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"tracksFeedbacks"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Task","preciseIdentifier":"s:ScT"},{"kind":"text","text":"<(), "},{"kind":"typeIdentifier","text":"Error","preciseIdentifier":"s:s5ErrorP"},{"kind":"text","text":">?"}],"abstract":[{"type":"text","text":"Sends "},{"type":"codeVoice","code":"action"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Actomaton"},{"type":"text","text":"."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/Actomaton\/send(_:priority:tracksFeedbacks:)","kind":"symbol","type":"topic","url":"\/documentation\/actomaton\/actomaton\/send(_:priority:tracksfeedbacks:)"},"doc://Actomaton/documentation/Actomaton/03-Timer":{"role":"article","title":"Example 3: Timer","abstract":[{"type":"codeVoice","code":"AsyncStream"},{"type":"text","text":"-based timer example."}],"identifier":"doc:\/\/Actomaton\/documentation\/Actomaton\/03-Timer","kind":"article","type":"topic","url":"\/documentation\/actomaton\/03-timer"}}}