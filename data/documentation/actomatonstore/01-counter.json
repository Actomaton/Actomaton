{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actomaton を使ったアプリのビジネスロジックを作成するために最低限、必要な情報は："}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Action (入力) の型定義"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"State (状態) の型定義"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reducer (状態遷移関数) の実装"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"の3つです。この例では、これらの定義の仕方について見ていきます。"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"（他にも、副作用に関連する "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":", "},{"type":"codeVoice","code":"Environment"},{"type":"text","text":", "},{"type":"codeVoice","code":"Route"},{"type":"text","text":" がありますが、この記事では使用しません）"}]},{"anchor":"カウンターのビジネスロジック","level":3,"type":"heading","text":"カウンターのビジネスロジック"},{"type":"paragraph","inlineContent":[{"type":"text","text":"今回は、"},{"type":"codeVoice","code":"increment"},{"type":"text","text":" と "},{"type":"codeVoice","code":"decrement"},{"type":"text","text":" を行うシンプルなカウンターを題材に、上記3点を次のように定義します。"}]},{"type":"codeListing","syntax":"swift","code":["import ActomatonStore","","\/\/ 入力アクション (Sendable が必要)","enum Action: Sendable {","    case increment","    case decrement","}","","\/\/ 状態 (Sendable が必要)","\/\/ NOTE: Equatable にしておくと差分更新とテスト比較がしやすいので、基本的に付けること。","struct State: Equatable, Sendable {","    var count: Int = 0","}","","\/\/ 外部環境からの副作用の依存注入は今回必要ないので、Void 。","\/\/ NOTE: Never ではないので注意。通常は struct で定義する。","typealias Environment = Void","","\/\/ 他画面へのルーティング処理は今回必要ないので、Never 。","\/\/ NOTE: Void ではないので注意。通常は enum で定義する。","typealias Route = Never","","\/\/ 状態遷移関数：アクションが送られる度に呼ばれる","let reducer: Reducer<Action, State, Environment>","reducer = Reducer { action, state, environment in","    switch action { \/\/ 受信したアクションをパターンマッチで分岐処理","    case .increment:","        state.count += 1    \/\/ 状態を更新","        return Effect.empty \/\/ 副作用を出力（ここでは空）","    case .decrement:","        state.count -= 1","        return Effect.empty","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"カウンターのビジネスロジックは以上で完成です。"}]},{"anchor":"カウンターの-UI-view-binding","level":3,"type":"heading","text":"カウンターの UI view binding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"上記のビジネスロジックを UI に反映する方法として、"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI View"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit View"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"それぞれについて見ていきます。"}]},{"anchor":"1.-SwiftUI-View-の場合","level":4,"type":"heading","text":"1. SwiftUI View の場合"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"RouteStore"},{"type":"text","text":" を "},{"type":"codeVoice","code":"@StateObject"},{"type":"text","text":" として View 内部で宣言します。"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"RouteStore"},{"type":"text","text":" の状態を参照するには "},{"type":"codeVoice","code":"store.state"},{"type":"text","text":"、次のアクションを送る場合は "},{"type":"codeVoice","code":"store.send()"},{"type":"text","text":" を呼び出します。"}]},{"type":"codeListing","syntax":"swift","code":["import SwiftUI","import ActomatonStore","","@MainActor","struct CounterView: View {","    \/\/ Store を作成","    @StateObject","    private var store: RouteStore<Action, State, Environment, Route> = .init(","        state: State(),","        reducer: reducer","    )","","    var body: some View {","        HStack {","            \/\/ ボタン： decrement を送信","            Button(action: { store.send(.decrement) }) {","                Image(systemName: \"minus.circle\")","            }","","            \/\/ 現在のカウントを画面に表示","            Text(\"Count: \\(store.state.count)\")","","            \/\/ ボタン： increment を送信","            Button(action: { store.send(.increment) }) {","                Image(systemName: \"plus.circle\")","            }","        }","    }","}"]},{"type":"aside","style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/RouteStore"},{"type":"text","text":" は外部出力可能なルーティング機能を持った "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/Store"},{"type":"text","text":" のサブクラスです。"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/Store"},{"type":"text","text":" は "},{"type":"codeVoice","code":"actor Actomaton"},{"type":"text","text":" を UI (メイン) スレッド用にラップしたクラスです。"}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/RouteStore"},{"type":"text","text":" の具体的な使い方については、"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/03-RouteStore"},{"type":"text","text":" で解説しています。"}]}]},{"anchor":"2.-UIKit-View-の場合","level":4,"type":"heading","text":"2. UIKit View の場合"},{"type":"paragraph","inlineContent":[{"type":"text","text":"UIKit では SwiftUI と異なり、UI binding を自ら実装しなくてはならない手間がかかりますが、"},{"type":"text","text":" "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" の状態更新を受け取る "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" ("},{"type":"codeVoice","code":"store.$state"},{"type":"text","text":") を使って簡単に実装することができます。"}]},{"type":"codeListing","syntax":"swift","code":["import UIKit","import ActomatonStore","import Combine","","final class ViewController: UIViewController {","    \/\/ Store を作成","    private let store: RouteStore<Action, State, Environment, Route> = .init(","        state: State(),","        reducer: reducer","    ) ","","    private var cancellables: Set<AnyCancellable> = []","","    override func viewDidLoad() {","        super.viewDidLoad()","","        let counterLabel = UILabel()","        let incrementButton = UIButton()","        let decrementButton = UIButton()","","        ...","","        \/\/ 以下は、RouteStore との UIKit view binding","","        store.$state","            .map { \"Count: \\($0.count)\" }","            .removeDuplicates() \/\/ NOTE: 前回分と比較して同じなら無視する","            .assign(to: \\.text, on: counterLabel)","            .store(in: &cancellables)","","        incrementButton.tapPublisher","            .sink { [store] in","                store.send(.increment) \/\/ アクションを送る","            }","            .store(in: &cancellables)","","        decrementButton.tapPublisher","            .sink { [store] in","                store.send(.decrement) \/\/ アクションを送る","            }","            .store(in: &cancellables)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"これで完成です！"},{"type":"text","text":" "},{"type":"codeVoice","code":"RouteStore"},{"type":"text","text":" を従来の MVVM ViewModel に見立てると、ほとんど書き方が似ていることが分かります。"}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"Actomaton が従来の MVVM と異なる点として次のようなものがあります："}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MVVM のメソッド”直接”呼び出しに対して、Actomaton では enum を使ってメソッド群を定義し、"},{"type":"codeVoice","code":"store.send(action)"},{"type":"text","text":" でメッセージとして送信している（“間接”呼び出し）"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MVVM では個々の状態の "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" を集めて（複雑な）"},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" 全体の状態が作られるのに対して、Actomaton では全体の状態がシンプルな "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" で出来ている"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"複数画面の状態を合成する際に、シンプルな構成の方が有利。例えば、"},{"type":"codeVoice","code":"store.$state"},{"type":"text","text":" で状態全体を1本の "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":" で一括で受け取れる (MVVM では事前に "},{"type":"codeVoice","code":"combineLatest"},{"type":"text","text":" 等をたくさん書く必要がある)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"状態がシンプルな "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" でもあるので、複数の状態をまとめて次の "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" (非同期計算)に渡すことが出来る"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"その一方で、UI binding 毎に "},{"type":"codeVoice","code":".map"},{"type":"text","text":" と "},{"type":"codeVoice","code":".removeDuplicates()"},{"type":"text","text":" を追加で書く手間がかかる"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actomaton のような「状態を一括で受け取れる」設計は、UI binding と差分更新が自動的に適用される SwiftUI で特に真価を発揮します。"},{"type":"text","text":" "},{"type":"text","text":"そのビジネスロジックの基本設計図をそのまま UIKit にも適用できるのが、この "},{"type":"codeVoice","code":"RouteStore"},{"type":"text","text":" を使った例です。"}]}]},{"anchor":"サンプルコード","level":2,"type":"heading","text":"サンプルコード"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm"}]}]}]},{"anchor":"Next-Step","level":2,"type":"heading","text":"Next Step"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/02-LoginLogout"}]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/actomatonstore\/01-counter"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/01-Counter","interfaceLanguage":"swift"},"abstract":[{"type":"codeVoice","code":"increment"},{"type":"text","text":" と "},{"type":"codeVoice","code":"decrement"},{"type":"text","text":" を行うカウンターの例"}],"kind":"article","metadata":{"roleHeading":"Article","title":"1. シンプルなカウンター","role":"article","modules":[{"name":"ActomatonStore"}]},"hierarchy":{"paths":[["doc:\/\/ActomatonStore\/documentation\/ActomatonStore"]]},"references":{"doc://ActomatonStore/documentation/ActomatonStore/RouteStore":{"role":"symbol","title":"RouteStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"RouteStore"}],"abstract":[{"type":"text","text":"Subclass of "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" that also outputs "},{"type":"codeVoice","code":"routes"},{"type":"text","text":", mainly used for UIKit’s navigation handling"},{"type":"text","text":" "},{"type":"text","text":"without using "},{"type":"codeVoice","code":"State"},{"type":"text","text":" as a single source of truth."}],"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/RouteStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"RouteStore"}],"url":"\/documentation\/actomatonstore\/routestore"},"doc://ActomatonStore/documentation/ActomatonStore/Store":{"role":"symbol","title":"Store","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[{"type":"text","text":"Store of "},{"type":"codeVoice","code":"Actomaton"},{"type":"text","text":" optimized for SwiftUI’s 2-way binding."}],"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/Store","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/actomatonstore\/store"},"https://github.com/Actomaton/Actomaton-Gallery/tree/main/Examples/Actomaton-Basic.swiftpm":{"title":"Actomaton-Basic","titleInlineContent":[{"type":"text","text":"Actomaton-Basic"}],"type":"link","identifier":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm","url":"https:\/\/github.com\/Actomaton\/Actomaton-Gallery\/tree\/main\/Examples\/Actomaton-Basic.swiftpm"},"doc://ActomatonStore/documentation/ActomatonStore/02-LoginLogout":{"role":"article","title":"2. 認証フローの状態管理・副作用管理","abstract":[{"type":"text","text":"認証フローで行われる複雑な状態管理とその副作用管理を扱う例"}],"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/02-LoginLogout","kind":"article","type":"topic","url":"\/documentation\/actomatonstore\/02-loginlogout"},"doc://ActomatonStore/documentation/ActomatonStore":{"role":"collection","title":"ActomatonStore","abstract":[{"type":"text","text":"Swift Concurrency (async\/await、Structured Concurrency、Actor) を使った、状態と副作用の管理のためのフレームワーク。"}],"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore","kind":"symbol","type":"topic","url":"\/documentation\/actomatonstore"},"doc://ActomatonStore/documentation/ActomatonStore/03-RouteStore":{"role":"article","title":"3. RouteStore によるルーティング","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/RouteStore"},{"type":"text","text":" を使って他の "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/RouteStore"},{"type":"text","text":" にメッセージングする例"}],"identifier":"doc:\/\/ActomatonStore\/documentation\/ActomatonStore\/03-RouteStore","kind":"article","type":"topic","url":"\/documentation\/actomatonstore\/03-routestore"}}}